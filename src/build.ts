import Fastify from "fastify";
import fastify_swagger from "@fastify/swagger";
import fastify_swagger_ui from "@fastify/swagger-ui";
import fastify_cookie from "@fastify/cookie";

import { SWAGGER_OPTS } from "./consts";

import decorators from "./decorators";
import plugins from "./plugins";
import routes from "./routes";
import "dotenv/config";
import { route_guard } from "./routes/handlers";
import { SWAGGER_TAGS } from "./consts";
function build(opts = {}) {
  const app = Fastify(opts);

  app.addHook("onRoute", (routeOptions) => {
    // Check the schema for public swagger tags
    const is_public = routeOptions.schema?.tags?.includes(SWAGGER_TAGS.public);
    // If the route is not public, add the route guard
    // NOTE: Routes generated by, e.g., @fastify/swagger, will have the schema
    // hidden, leaving the tags undefined. Since we don't actually want those routes
    // to have the same auth requirements as the regular private routes, we check
    // for an explicitly false value, rather than just a falsy one.
    if (is_public === false) {
      routeOptions.preHandler = route_guard;
    }
  });

  // Swagger
  app.register(fastify_swagger, SWAGGER_OPTS);
  app.register(fastify_swagger_ui, {
    routePrefix: "/docs",
    uiConfig: {
      docExpansion: "list",
      deepLinking: false,
    },
    staticCSP: false,
  });

  // Fastify cookie movies cookies to their own section of the Response object
  app.register(fastify_cookie);

  // Decorators
  for (const decorator in decorators) {
    app.decorate(decorator, decorators[decorator]);
  }

  // Plugins
  for (const { plugin, options } of Object.values(plugins)) {
    app.register(plugin, options);
  }

  // Routes
  for (const route of routes) {
    app.register(route, opts);
  }

  return app;
}

export default build;
